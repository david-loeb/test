---
title: "Data Cleaning"
format: dashboard
theme: cosmo
# include-in-header:
#   text: "<style> .observablehq--string {color: white;} </style>"
---

```{r}
suppressMessages(library(dplyr)); library(stringr); library(purrr)
source(str_c(this.path::here(), '/../0_functions_analysis.r'))
source(str_c(this.path::here(), '/../0_functions_results.r'))
df <- left_join(
  arrow::read_parquet(str_c(this.path::here(), '/../../data/lea_final.parquet')),
  arrow::read_parquet(str_c(this.path::here(), "/../../data/policies_final.parquet")),
  c("st", "year")
)
```

```{r}
df <- df |> 
  mutate(
    yrs_in_panel_cnslr = sum(!is.na(staff_cnslr_pp[year >= 2005 & year <= 2024])),
    yrs_in_panel_sup = sum(!is.na(staff_sup_stdnt_pp[year >= 2005 & year <= 2024])),
    yrs_in_panel_exp_pp = sum(!is.na(exp_sup_stdnt_pp[year >= 2005 & year <= 2022])),
    yrs_in_panel_exp_pct = sum(!is.na(exp_sup_stdnt_pct_exp_tot[year >= 2005 & year <= 2022])),
    .by = leaid
  ) |>
  mutate(exp_sup_stdnt_pct_exp_tot = exp_sup_stdnt_pct_exp_tot * 100)

df_lea <- df |> 
  filter(year >= 2005) |>
  mutate(
    exclstaff_cnslr_pp = case_when(
      o_staff_cnslr == 0 & yrs_in_panel_cnslr == 20 ~ 'all no outliers bal panel',
      o_staff_cnslr == 0 ~ 'all no outliers',
      .default = 'all'
    ),
    exclstaff_sup_stdnt_pp = case_when(
      o_staff_sup_stdnt == 0 & yrs_in_panel_sup == 20 ~ 'all no outliers bal panel',
      o_staff_sup_stdnt == 0 ~ 'all no outliers',
      .default = 'all'
    ),
    exclexp_sup_stdnt_pp = case_when(
      o_exp_sup_stdnt == 0 & yrs_in_panel_exp_pp == 18 ~ 'all no outliers bal panel',
      o_exp_sup_stdnt == 0 ~ 'all no outliers',
      .default = 'all'
    ),
    exclexp_sup_stdnt_pct_exp_tot = case_when(
      o_exp_sup_stdnt_pct_exp_tot == 0 & yrs_in_panel_exp_pct == 18 ~ 'all no outliers bal panel',
      o_exp_sup_stdnt_pct_exp_tot == 0 ~ 'all no outliers',
      .default = 'all'
    )
  ) |>
  select(
    leaid, st, year, staff_cnslr_pp, staff_sup_stdnt_pp,
    exp_sup_stdnt_pp, exp_sup_stdnt_pct_exp_tot,
    exclstaff_cnslr_pp, exclstaff_sup_stdnt_pp,
    exclexp_sup_stdnt_pp, exclexp_sup_stdnt_pct_exp_tot
  )

exclusions <- list(
  expr(TRUE),
  expr(o_staff_cnslr == 0),
  expr(o_staff_cnslr == 0 & yrs_in_panel_cnslr == 20),
  expr(TRUE),
  expr(o_staff_sup_stdnt == 0),
  expr(o_staff_sup_stdnt == 0 & yrs_in_panel_sup == 20),
  expr(TRUE),
  expr(o_exp_sup_stdnt == 0),
  expr(o_exp_sup_stdnt == 0 & yrs_in_panel_exp_pp == 18),
  expr(TRUE),
  expr(o_exp_sup_stdnt_pct_exp_tot == 0),
  expr(o_exp_sup_stdnt_pct_exp_tot == 0 & yrs_in_panel_exp_pct == 18)
)

outcomes <- rep(
  c(
    'staff_cnslr_pp', 'staff_sup_stdnt_pp', 
    'exp_sup_stdnt_pp', 'exp_sup_stdnt_pct_exp_tot'
  ), 
  each = 3
)

excl <- rep(
  c('all', 'no outliers', 'bal panel'), 4
)

df_st <- pmap(list(exclusions, outcomes, excl), ~ summarise(
  filter(df, year >= 2005, eval(..1)),
  out = mean(get(..2), na.rm = T),
  y = ..2,
  excl = ..3,
  .by = c(st, year)
)) |>
  list_rbind() |>
  mutate(id = str_c(st, year, y, excl))

# st_avg_all <- df |> mutate(
#   cnslr = mean(staff_cnslr_pp, na.rm = T),
#   sup = mean(staff_sup_stdnt_pp, na.rm = T),
#   exp_pp = mean(exp_sup_stdnt_pp, na.rm = T),
#   exp_pct = mean(exp_sup_stdnt_pct_exp_tot, na.rm = T),
#   enroll = mean(enroll, na.rm = T),
#   n_cnslr = sum(!is.na(staff_cnslr_pp)),
#   n_sup = sum(!is.na(staff_sup_stdnt_pp)),
#   n_exp = sum(!is.na(exp_sup_stdnt_pp)),
#   .by = c(st, year)
# )

ojs_define(data_st_og = df_st)
ojs_define(data_lea_og = df_lea)
```

```{ojs}
//| output: false
d3 = require('d3@7')

data_st = transpose(data_st_og)
data_st_filt = data_st.filter(d => 
  st_select.includes(d.st) &&
  exclusion.includes(d.excl) &&
  outcome.includes(d.y)
)
data_lea = transpose(data_lea_og);
data_lea.forEach(item => {
  Object.assign(item, {out: item[outcome], excl: item['excl' + outcome]})
});
data_lea_filt = data_lea.filter(d => d.excl.includes(exclusion));

allStates = [...new Set(data_st.map(d => d.st))];
mutable clickedState = null;
mutable messyDistricts = 'st,leaid,year;';
exclusionMap = new Map(
  [['None', 'all'], 
  ['Outliers', 'no outliers'], 
  ['Unbal', 'bal panel']]
);
outcomeMap = new Map(
  [['Cnslr', 'staff_cnslr_pp'],
  ['Sup', 'staff_sup_stdnt_pp'],
  ['Exp pp', 'exp_sup_stdnt_pp'],
  ['Exp pct', 'exp_sup_stdnt_pct_exp_tot']]
);
```

## Sidebar {.sidebar width="125px"}

```{ojs}
viewof st_select = Inputs.select(
  data_st_og.st, {label: "State", unique: true, multiple: true, value: allStates}
)
viewof exclusion = Inputs.radio(
  exclusionMap, {label: 'Exclusions', value: 'no outliers'}
)
viewof outcome = Inputs.radio(
  outcomeMap, {label: 'Outcome', value: 'staff_cnslr_pp'}
)
```

## Content {width=90%}

### States Plot

```{ojs}
/* Note: for responsive layout, one option is to define only the height, and then dont define a height or width on the SVG, and in viewbox set it to the width and height; this will have it autoresize pretty nicely, tho it doesnt actually fill the box */

/* Another option is define both width and height and set SVG */
{
  const margin = ({top: 20, right: 20, bottom: 30, left: 40});  // Dimensions
  const height = 450;
  //const width = 400;

  const x = d3.scaleLinear()  // Scale functions
    .domain(d3.extent(data_st_filt, d => d.year))
    .range([margin.left, width - margin.right]);
  const y = d3.scaleLinear()
    .domain([0, d3.max(data_st_filt, d => d.out) + 50])
    .range([height - margin.bottom, margin.top])
    .nice();

  const svg = d3.create('svg')  // Parent SVG
    //.attr('height', height)
    //.attr('width', width)
    .attr('viewBox', [0, 0, width, height]);
    //.attr('preserveAspectRatio', 'xMidYMid meet');
  
  const xAxis = d3.axisBottom(x)  // Axes
    .tickFormat(d3.format('d'));
  const yAxis = d3.axisLeft(y);
  svg.append('g')
    .attr('transform', `translate(0, ${height - margin.bottom})`)
    .call(xAxis)
    .selectAll('.tick text')
    .attr('font-size', '16px');
  svg.append('g')
    .attr('transform', `translate(${margin.left}, 0)`)
    .call(yAxis);

  const points = data_st_filt.map(d => [x(d.year), y(d.out), d.st])  // Lines
  const groups = d3.rollup(points, v => Object.assign(v, {z: v[0][2]}), d => d[2]);
  const line = d3.line().defined(d => !isNaN(d[1]));
  const path = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke', 'steelblue')
    .attr('stroke-width', 3.5)
    .attr('stroke-linejoin', 'round')
    .selectAll('path')
    .data(groups.values())
    .join('path')
    .style('mix-blend-mode', 'multiply')
    .attr('d', line);
  
  const dot = svg.append('g')  // Dot (for hover)
    .attr('display', 'none');
  dot.append('circle')
    .attr('r', 2.5);
  dot.append('text')
    .attr('text-anchor', 'middle')
    .attr('y', -8);
  const dotClick = svg.append('g')

  let xHover = null,
    yHover = null,
    xClick = null,
    yClick = null,
    hoveredSeries = null,
    activeSeries = allStates,
    clickCounter = null;

  svg  // Event listeners
    .on('pointerenter', pointerEntered)
    .on('pointermove', pointerMoved)
    .on('pointerleave', pointerLeft)
    .on('click', clicked);

  return svg.node();

  function pointerMoved(event) {  // Event handler functions
    if (clickCounter % 2 == 1) {
      activeSeries = hoveredSeries;
    } else {
      activeSeries = allStates;
    }
    const activePoints = points.filter(d => activeSeries.includes(d[2]));
    const [xm, ym] = d3.pointer(event);
    const i = d3.leastIndex(activePoints, ([x, y]) => Math.hypot(x - xm, y - ym));
    [xHover, yHover, hoveredSeries] = activePoints[i];
    path
      .style('stroke', ({z}) => z === hoveredSeries ? null : '#ddd')
      .filter(({z}) => z === hoveredSeries)
      .raise();

    const pctChange = d3.format('.1%')(
      (y.invert(yHover) - y.invert(yClick)) / y.invert(yClick)
    );
    dot.attr('transform', `translate(${xHover}, ${yHover})`);
    if (clickCounter % 2 == 1) {
      dot.select('text').text(`${hoveredSeries} ${pctChange}`)
    } else {
      dot.select('text').text(hoveredSeries);
    }
  }

  function clicked(event) {
    clickCounter++;
    if (clickCounter % 2 == 1) {
      xClick = xHover;
      yClick = yHover;
      dotClick.append('circle')
        .attr('r', 2.5)
        .attr('transform', `translate(${xClick}, ${yClick})`);
    } else {
      dotClick.select('circle').remove();
    }
    mutable clickedState = hoveredSeries;
  }

  function pointerEntered() {
    path.style('mix-blend-mode', null).style('stroke', '#ddd');
    dot.attr('display', null);
  }

  function pointerLeft() {
    if (clickCounter % 2 == 0) {
      path.style('mix-blend-mode', 'multiply').style('stroke', null);
      dot.attr('display', 'none');
    } else {
      return;
    }
  }
}
```

### plot 2

```{ojs}
{
  const margin = ({top: 20, right: 20, bottom: 30, left: 40});  // Dimensions
  const height = 450;

  const activeData = data_lea_filt.filter(d => d.st === clickedState)
  const x = d3.scaleLinear()  // Scale functions
    .domain(d3.extent(activeData, d => d.year))
    .range([margin.left, width - margin.right]);
  const y = d3.scaleLinear()
    .domain([0, d3.max(activeData, d => d.out) + 50])
    .range([height - margin.bottom, margin.top])
    .nice();

  const svg = d3.create('svg')  // Parent SVG
    .attr('viewBox', [0, 0, width, height]);
  
  const xAxis = d3.axisBottom(x)  // Axes
    .tickFormat(d3.format('d'));
  const yAxis = d3.axisLeft(y);
  svg.append('g')
    .attr('transform', `translate(0, ${height - margin.bottom})`)
    .call(xAxis)
    .selectAll('.tick text')
    .attr('font-size', '16px');
  svg.append('g')
    .attr('transform', `translate(${margin.left}, 0)`)
    .call(yAxis);

  const points = activeData.map(d => [x(d.year), y(d.out), d.leaid, d.st])  // Lines
  const groups = d3.rollup(points, v => Object.assign(v, {z: v[0][2]}), d => d[2]);
  const line = d3.line().defined(d => !isNaN(d[1]));
  const path = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke', 'steelblue')
    .attr('stroke-width', 3.5)
    .attr('stroke-linejoin', 'round')
    .selectAll('path')
    .data(groups.values())
    .join('path')
    .style('mix-blend-mode', 'multiply')
    .attr('d', line);
  
  const dot = svg.append('g')  // Dot (for hover)
    .attr('display', 'none');
  dot.append('circle')
    .attr('r', 2.5);
  dot.append('text')
    .attr('text-anchor', 'middle')
    .attr('y', -8);
  const dotClick = svg.append('g')

  const allDistricts = [...new Set(activeData.map(d => d.leaid))]
  let xHover = null,
    yHover = null,
    xClick = null,
    yClick = null,
    hoveredSeries = null,
    activeSeries = allDistricts,
    pctChange = null,
    clickCounter = null;

  svg.append('text')
    .attr('x', width / 2)
    .attr('y', margin.top / 2)
    .attr('text-anchor', 'middle')
    .style('font-size', '16px')
    .text(clickedState);

  svg  // Event listeners
    .on('pointerenter', pointerEntered)
    .on('pointermove', pointerMoved)
    .on('pointerleave', pointerLeft)
    .on('click', clicked);

  return svg.node();

  function pointerMoved(event) {  // Event handler functions
    if (clickCounter % 2 == 1) {
      activeSeries = hoveredSeries;
    } else {
      activeSeries = allDistricts;
    }
    const activePoints = points.filter(d => activeSeries.includes(d[2]));
    const [xm, ym] = d3.pointer(event);
    const i = d3.leastIndex(activePoints, ([x, y]) => Math.hypot(x - xm, y - ym));
    [xHover, yHover, hoveredSeries] = activePoints[i];
    path
      .style('stroke', ({z}) => z === hoveredSeries ? null : '#ddd')
      .filter(({z}) => z === hoveredSeries)
      .raise();

    pctChange = d3.format('.1%')(
      (y.invert(yHover) - y.invert(yClick)) / y.invert(yClick)
    );
    dot.attr('transform', `translate(${xHover}, ${yHover})`);
    if (clickCounter % 2 == 1) {
      dot.select('text').text(`${hoveredSeries} ${pctChange}`)
    } else {
      dot.select('text').text(hoveredSeries);
    }
  }

  function clicked(event) {
    clickCounter++;
    if (clickCounter % 2 == 1) {
      xClick = xHover;
      yClick = yHover;
      dotClick.append('circle')
        .attr('r', 2.5)
        .attr('transform', `translate(${xClick}, ${yClick})`);
      mutable messyDistricts = mutable messyDistricts + 
        `${clickedState},${hoveredSeries},${Math.round(x.invert(xClick))};`;
    } else {
      dotClick.select('circle').remove();
    }
  }

  function pointerEntered() {
    path.style('mix-blend-mode', null).style('stroke', '#ddd');
    dot.attr('display', null);
  }

  function pointerLeft() {
    path.style('mix-blend-mode', 'multiply').style('stroke', null);
    dot.attr('display', 'none');
  }
}
```

## Messy Districts {width=10%}

```{ojs}
messyDistricts;
```

```{r}
#| eval: false
# Code to turn the text from messyDistricts into data in R
# Paste text into a file, here named 'messy_lea.txt', then run below
file_name <- here::here('messy_lea.txt')
file_content <- readChar(file_name, file.info(file_name)$size) |> 
  stringr::str_split_1(filecontent, ';') |> 
  stringr::str_split(filecontent2, ',')
df_messy_lea <- as.data.frame(do.call(rbind, filecontent3)) |> 
  janitor::row_to_names(1)
```